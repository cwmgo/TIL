# List2

## 2차원 list

2차원 List 구조

- 1차원 List를 묶어놓은 List

- 2차원 이상의 다차원 List는 차원에 따라 Index를 선언

- 2차원 List의 선언: 세로길이(행의 개수), 가로길이(열의 개수)를 필요로 함.

  2행 4열의 2차원 List

  arr = [[0,1,2,3],[4,5,6,7]]

  0 1 2 3

  4 5 6 7

  tip: 파이썬에서는 데이터 초기화를 통해 변수선언과 초기화가  가능함.

list 초기화

```python
arr = [0, 0, 0, 0, 0]
arr = [0]*5
arr = [i for i in range(2, 9) if i%2==0] #[2,4,6,8]

brr=[[1,2,3],[1,2,3],[1,2,3]]
brr=[[1,2,3]]*3 #[[1,2,3],[1,2,3],[1,2,3]]
brr=[[1,2,3]for i in range(3)]#[[1,2,3],[1,2,3],[1,2,3]]
brr=[[i,j]for i in range(3) for j in range(2)]
#[[0,0],[0,1],[1,0],[1,1],[2,0],[2,1]]
```



-2차원 list 입력 받기.

첫째 줄에 n행 m열.

둘째줄부터 n*m의 행열 데이터가 주어질 경우 입력을 받는 방법.

```python
n, m = map(int, input().split())

mylist=[0 for_ in range(n)]
#mylist = [0]*n

for i in range(n):
    mylist[i] = list(map(int,input().split()))
```

tip: 시퀀스자료형의 *(곱셈) 연산자로 반복을 이용하는 방법도 가능함.



```python
n,m = map(int, input().split())
mylist=[list(map(int, input().split())) for _ in range(n)]
```

-2차원 List에서 원하는 데이터의 위치 찾기

주어진 데이터에서 1이 입력된 [행,열]의 위치 찾기

```python
n,m = map(int, input().split())
newlist=[]
mylist=[0 for _ in range(n)]
for i in range(n):
    mylist[i]=list(map(int,input().split()))
    for j in range (m):
        if
```

## 부분집합의 합 문제

유한개의 정수로 이루어진 집합이 있을때, 이집합의 부분집합중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제.

EX) {-7, -3, -2, 5, 8}

(1) {-3, -2 ,5} 는 부분집합.

(2) -3 -2 +5 = 0

답은 참이다.



1.완전 검색기법으로 부분 집합 합 문제를 풀기 위해서는 우선 집합의 모든 부분 집합을 생성한 후 각 부분 집합의 합을 계산함.

2.주어진 집합의 부분 집합을 생성하는 방법 생각해 보기

-부분집합의 수

Q. 어떤 집합의 부분집합을 구할 경우 부분 집합의 총 개수가 몇개 일까요?

A. (1) 집합의 원소가 n개 일때, 공집합을 포함한 부분 집합의 수는 2^n 개

​	(2) 각 원소를 부분 집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같음.

ex) {1, 2, 3, 4} => 2* 2* 2* 2 = 16가지



Loop를 이용하여 확인하고, 부분집합을 생성하는 방법

```python
bit = [0, 0, 0, 0]
for i in range(2):
    bit[0] = i #0번째 원소
    for j in range(2):
        bit[1] = j #1번째 원소
        for k in range(2):
            bit[2] = k
            for l in range(2):
                bit[3] = l #3번째 원소
                print(bit) #생성된 부분집합 출력
```

비트 list. 대상 list의 각 원소를 포함할지 말지를 정하는 List

bit로 생각해보면 1111 => 15를 뜻한다.



-부분집합 문제 알고리즘 2

비트연산자: 0과 1로 이루어진 이진수에 대한 연산을 수행하는 연산자

비트연산자 종류

 & : 비트 단위로 AND 연산을 함

 | : 비트 단위로 OR 연산을 함

<<: 피연산자의 비트 열을 왼쪽으로 이동시킴

'>> : 피연산자의 비트열을 오른쪽으로 이동시킴.

1 << n : 2^n을 뜻하게 된다. 원소가 n개일 경우의 모든 부분집합의 수를 의미한다.

i & (1<<j) :  i에서 j번째 비트가 1인지 아닌지를 리턴함.

보다 간결하게 부분집합을 생성하는 방법

```python
arr = [3, 6, 7, 1, 5, 4]
n = len(arr) # n:원소의 개수

for i in range(1<<n): #1 << n: 부분집합의 개수
    for j in range(n) : # 원소의 수 만큼 비트를 비교함, 원소의 포함 여부 판단이 가능함.
        if i&(1<<j): # i의 j번째 비트가 1이면 번째 원소 출력
            print(arr[j], end=",")
    print()
```











