# 01 알고리즘

* 알고리즘이란? 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법

1. 컴퓨터 용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법

2. 어떠한 문제를 해결하기 위한 절차.



* 알고리즘 표현법

  슈도코드: 특정 프로그래밍 언어의 문법을 따라 쓰여진 것이 아니라, 이랍ㄴ적인 언어로 코드를 흉내내어 알고리즘을 써 놓은 코드.  의사코드로 흉내만 내는 코드. 실제적인 프로그래밍 언어로 작성된 코드처럼 컴퓨터에서 실행할 수 없음. 특정언어로 프로그램을 작성하기 전에 알고리즘을 대략적으로 모델링하는데 사용



​	 순서도: 프로그램이나 작업의 진행 흐름을 순서에 따라 여러가지 기호나 문자로 나타낸 도표

​					흐름도, 프로그램의 논리적인 흐름, 데이터의 처리 과정을 표현하는데 사용.

​				프로그램을 작성하기전에 프로그램의 전체적인 흐름과 과정 파악을 위해 필수적으로거쳐야 되는작업







## 2. 알고리즘의 성능 분석



* 무엇이 좋은 알고리즘인가?

  정확성: 얼마자 정확하게 동작하는가?

  작업량: 얼마나 적은 연산으로 원하는 결과를 얻어내는가?

  메모리사용량: 얼마나 적은 메모리를 사용하는가?

  단순성: 얼마나 단순한가?

  최적성: 더 이상 개선할 여지 없이 최적화 되었는가?



* 알고리즘의 성능 분석 필요

  많은 문제에서 알고리즘의 성능 분석 기준으로 알고리즘의 작업량을 비교

  * 방법1: 실제걸리는 시간을 측정.
  * 방법2: 실행되는 명령문의 개수를 계산(실행되는 환경에 따라 바뀔 수 있음.)

```python
def calcSum(n):									def calcSum(n):
    sum = 0 # 1번									return n*(n+1)//2 # 3번
    for i in range(1, n+1): #1번					=> 3번의 연산
        sum= sum + i # 1번
    return sum
=> 1 + n*2 = 2n +1
```

​	시간복잡도  = 빅-오 표기법

​	-시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시.

​	-계수 는 생략하여 표시.

​	O(2n + 1) = O(2n) = O(n)

​	O(2n^2 + 10n + 100) = O(n^2)

​	O(4) = O(1)

​	요소수의 제곱수로 표현되는 알고리즘의 경우 연산수가 증가하면 기하급수적으로 증가하므로 유의하여 사용

​	해야 한다.

​	logN < N < NlogN < N^2 < N^3 < 2^N



## 2.List

* Python 소개

  * 파이썬은 인터프리터 언어로 실행시마다 소스를 기계어로 컴파일 하는 방식이라 플랫폼에 상관없이 실행이 가능.
  * 객체지향
  * 파이썬 3으로 진화.
  * IoT분야의 라즈베리파이, 최근 빅데이터의 자료분석 등에서 파이썬의 관심이 높아짐.

  

  -프로그램 실행 속도에 관심 집중

  예전 하드웨어 성능이 좋지않던 시기에는 프로그램의 실행 속도가 크게 차이가 남.

   => 실행속도가 느린 파이썬이 주목받지 못함.

  

  -개발 시간 단축에 관심 집중

  하드웨어의 성능 개선으로 실행 속도의 차이가 크지않음.

  => 많은 개발자들이 파이썬을 사용함.

  

  -변수

  1.파이썬에서는 모든 자료는 객체 => Java나 C에서 사용되는 기본형 타입 변수도 파이썬에서는 객체

  2.변수의 선언은 따로 없음 => 변수에 값을 초기화 시 변수가 메모리에 생성. 하나의 변수에 다른 타입의 값을 	변수에 저장할 수 있음. 모든변수는  참조형타입의 변수로 실제 데이터가 저장되어 있는 메모리 주소를 저

  ​	장함. 저장되어있는 데이터 타입에 따라 변수타입이 바뀐다.

  

  -자료형

  type() : 타입 , int : 정수, float: 실수, complex: 복소수, bool: 부울, str: 문자열, tuple: 튜플, list: 리스트, dict: 사전, set: 셋, NoneType: None, function: 함수, 클래스명 : 클래스

  

  -![1564547859536](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1564547859536.png)

  list보다 tuple의 처리속도가 더 빠르다. 따라서 데이터를 변경하지않는다면 tuple을 써야.

  set은 슬라이싱은 불가능

* 배열(list): 같은 타입 변수들을 하나의 이름으로 열거하여 사용하는 자료구조.

  파이썬의 리스트는 C나 Java에서의 배열과 비슷한 자료구조.

  변수를 사용하여 리스트로 바꾸어 사용함.

  -리스트를 사용하면 하나의 변수를 통해서 대량의 데이터를 효율적으로 처리할 수 있음.

  ex) 함수호출시 몇개의 인자를 함수로 전달할때 리스트를 이용할 수 있다.



* List 사용법

  -파이썬의 변수

  별도의 선언방법이 없으며 변수에 처음 값을 할당할 때 생성

  값을 초기화 하기 전에, 변수를 미리 만들어 두어야 할 경우

  num = [] , arr = list() 

  => 공백 리스트 생성.

  -배열과 리스트의 차이점.

  arr = [1, 3.14, "boy", [1, 2, "girl"]]

  배열: 같은 타입의 데이터만 저장, 처음 저장한 후 변경할 수 없음.

  리스트: 다양한 데이터를 저장할 수 있음. 가변적으로 변경할 수 있음.

  => 배열보다 리스트가 사용하기 편리함.



​		시퀀스(Sequence) 자료형

​		순서가 존재함으로, 인덱싱과 슬라이싱의 연산 모두 적용가능.

​		인덱싱: 시퀀스 자료형에서 하나의 요소를 인덱스 연산자를 통하여 참조하는것

​		슬라이싱: 시퀀스 자료형의 원하는 범위를 선택하는 연산.(종료인덱스는 미포함.)

​		

​		-리스트는 시퀀스자료형임.

​		다양한 함수들이 있더라.

​	![1564552235222](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1564552235222.png)

![1564552262026](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1564552262026.png)



* 리스트 함축(list Comprehension)

  수학에서 집합을 정의하는 표현식과 유사함.



## Exhaustive Search

완전검색: 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법

1. Brute-force 혹은 Generate-and-Test 기법이라고도 불림
2. 모든 경우의 수를 테스트한 후, 최종 해법을 도출함.
3. 일반적으로 경우의 수가 상대적으로 작을 때 유용함.
4. 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 적음.
5. 주어진 문제를 풀 때, 우선 완전 검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직함.

ex) Baby-gin 게임

1.0~9 사이의 숫자 카드에서 임의의 카드 6장을 뽑았을 때, 3장의 카드가 연속적인 번호를 갖는 경우를 run이라 하고, 3장의 카드가 동일한 번호를 갖는 경우를 triplete이라고 함.

2.6장의 카드가 run과 triplete로만 구성된 경우를 Baby-gin으로 부름.

입력

667767은 두개의 triplete이므로 baby-gin

출력 => 666,777



완전검색으로 푼 baby-gin 여부 찾기.



1.고려할 수 있는 모든 경우의 수 생성하기 => 6개의 숫자로 만들 수 있는 모든 숫자 나열(중복포함)

=> 입력으로 {2, 3, 5, 7, 7, 7}을 받았을 경우, 아래와 같이 순열을 생성할 수 있음.



2. 해답 테스트하기

   앞의 3자리와 뒤의 3자리를 잘라, run와 triplete여부를 테스트하고 최종적으로 Baby-gin을 판단함.

이러한 방법을 완전 검색이라고 한다.



* 순열 (서로 다른 것들 중 몇개를 뽑아서 한줄로 나열하는것)

1. 서로다른 n개중 r개를 택하는 순열은 nPr
2. nPr = n* (n-1)* (n-2)* ... (n-r+1)
3. nPn = n! 이라고 표기하며 Factorial이라부름.



ex) {1, 2, 3}을 포함하는 모든 순열을 생성하는 함수.

동일한 숫자가 포함되지 않았을때, 각 자릿수 별로 100p을 이용

```python
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i2 != i1:
            for i3 in range(1,4):
                if i3 != i1 and i3 !=i2:
                    print(i1, i2, i3)
```



* 탐욕 알고리즘

  최적 해를 구하는데 사용되는 근시안적인 방법

  1. 여러경우 중 하나를 결정해야 할 떄마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달함.
  2. 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그것들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없음.
  3. 일반적으로, 머리속에 떠오르는 생각을 검증 없이 바로 구현하면 Greedy접근이 됨.

* 탐욕 알고리즘의 수행과정

  해 선택: 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합 에 추가함.

  실행 가능성 검사: 새로운 부분 해 집합이 실행 가능한지를 확인. 곧, 문제의 제약조건을 위반하지 않는지를 검사함.

  해 검사: 새로운 부분 해 집합이 문제의 해가 되는지를 확인. 아직 전체 문제의 해가 완성되지 않았다면 해 선택부터 다시 시작함.

* 거스름돈 줄이기

  어떻게 하면 손님에게 거스름돈으로 주는 지폐와 동전의 개수를 최소한으로 줄일 수 있을까?

  해 선택: 가장 좋은 해를 선택. 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가함.

  실행가능성 검사: 거스름돈이 손님에게 내드려야 할 액수를 초과하는지를 확인.

  ​								초과 한다면 마지막에 추가한 동전을 거스름돈에서 빼고, 해 선택으로 돌아가서 현재보

  ​								다 한 단계 작은 단위의 동전을 추가함.

  해 검사: 거스름돈이 손님에게 내드려야 하는 액수와 일치하는지 확인. 액수에 모자라면 다시 해 선택으로 

  ​				돌아가서 거스름돈에 추가할 동전을 고름.

* 완전검색이 아닌 baby-gin 방법으로 풀기

  1. 6개의 숫자는 6자리의 정수 값으로 입력됨.

  2. COUNTS 리스트의 각 원소를 체크하여 run과 triplate및 Baby-gin 여부를 판단함.

     -탐욕 알고리즘을 적용함

     -COUNTS 리스트에서 run과 triplete중에 가능한 것을 조사함.

     -조사에 사용한 데이터는 삭제함.

     -남은 데이터를 다시 run과 triplete 중에 가능한지를 조사함.

     

![1564557668502](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1564557668502.png)

```python
num = 456789
c = [0]* 12

for i in range(6):
    c[num % 10] += 1
    num //= 10
i = 0
tri = run = 0
while i < 10:
    if c[i] >= 3
       c[i] -= 3
       tri += 1
       countinue;
    if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1
       c[i] -= 1
       c[i+1] -= 1
       c[i+2] -= 1
       run += 1
       continue
    i += 1
if run + tri == 2: print("Baby Gin")
```



탐욕 알고리즘 접근의 경우, 해답을 찾아내지 못할 때

- 입력 받은 숫자를 정렬한 후, 앞뒤 3자리씩 끊어서 run 및 triplete을 확인하는 방법을 고려.

  ex)  {6, 4, 4, 5, 4, 4} : 정렬하여 {4, 4, 4, 4, 5, 6}을 얻어내면 쉽게 baby-gin을 확인할 수 있음.

  {1, 2, 3, 1, 2, 3} : 정렬하면 {1, 1, 2, 2, 3, 3}로서, 오히려 Baby-gin 확인을 실패할 수 있음.



## Sort

정렬이란? 2개이상의 자료를 특정 기준에 의해 작은값부터 큰값, 혹은 그 반대의 순서대로 재배열 하는것.

키란 자료를 정렬하는 기준이 되는 특정 값.



* 대표적인 정렬 방식의 종류

  버블정렬, 카운팅 정렬, 선택정렬, 퀵 정렬, 삽입 정렬, 병합 정렬

* 버블정렬: 인접한 두개의 원소를 비교하며 자리를 계속 교환하는 방식

  정렬과정: 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동

  -> 한 단계가 끝나면 가장 큰 원소 또는 가장 작은 원소가 마지막 자리로 정렬됨.

  ->교환 하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양 같아서 버블 정렬이라고 함.

  시간복잡도 = O(n^2)

  예) {55, 7, 78, 12, 42}를 버블 정렬하는 과정.

  ![1564558225145](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1564558225145.png)

  ​		

![1564558251801](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1564558251801.png)

![1564558271527](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1564558271527.png)

![1564558291657](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1564558291657.png)



* 카운팅 정렬

  항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘.

* 정렬과정

  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능. 각항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 리스트를 사용하기 떄문임.

  - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 함.

    시간복잡도 = O(n + k): n은 리스트의 개수, k는 정수의 최대값.

  {0, 4, 1, 3, 1, 2, 4, 1}을 카운팅 정렬하는 과정

  ![1564558497632](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1564558497632.png)

![1564558524674](C:\Users\student\AppData\Roaming\Typora\typora-user-images\1564558524674.png)

카운팅정렬은 검색해서보자.